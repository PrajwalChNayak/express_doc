<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Error Handling | Express.js Documentation</title>
  <!-- Tailwind CSS via CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gray-100 min-h-screen flex flex-col">
  <!-- Header will be inserted here by JavaScript -->
  <div id="header"></div>
  
  <main class="container mx-auto px-4 py-8 flex-grow">
    <div class="max-w-4xl mx-auto bg-white rounded-lg shadow-lg p-8">
      <h1 class="text-3xl font-bold mb-6 text-gray-800 border-b pb-4">Error Handling in Express.js</h1>
      
      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Introduction to Error Handling</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          Error handling in Express refers to how Express catches and processes errors that occur both synchronously and asynchronously. Express comes with a default error handler that takes care of any errors that might occur in your application, but you can also write your own error-handling middleware to customize this behavior.
        </p>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Default Error Handler</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          Express comes with a built-in error handler that handles any errors that might occur in your app. This default error-handling middleware function is added at the end of the middleware function stack.
        </p>
        <p class="mb-4 text-gray-600 leading-relaxed">
          If you pass an error to <code class="bg-gray-200 px-1 py-0.5 rounded">next()</code> and you do not handle it in a custom error handler, it will be handled by the built-in error handler; the error will be written to the client with the stack trace.
        </p>
        <div class="bg-yellow-100 border-l-4 border-yellow-500 p-4 mb-4">
          <p class="text-yellow-700">
            <strong>Note:</strong> The default error handler is only active in the development environment. In production, you should implement your own error-handling middleware.
          </p>
        </div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Writing Error Handlers</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          Error-handling middleware functions are defined just like regular middleware functions, except they take four arguments instead of three: <code class="bg-gray-200 px-1 py-0.5 rounded">(err, req, res, next)</code>. The extra argument <code class="bg-gray-200 px-1 py-0.5 rounded">err</code> holds the error.
        </p>
        <div class="bg-gray-800 text-white p-4 rounded-md mb-4 overflow-x-auto">
          <code>
            app.use((err, req, res, next) => {<br>
            &nbsp;&nbsp;console.error(err.stack);<br>
            &nbsp;&nbsp;res.status(500).send('Something broke!');<br>
            });
          </code>
        </div>
        <p class="mb-4 text-gray-600 leading-relaxed">
          Error-handling middleware should be defined last, after all other app.use() and route calls.
        </p>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Handling Route Errors</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          In route handlers and middleware, you can use <code class="bg-gray-200 px-1 py-0.5 rounded">next()</code> to pass control to the next middleware function. If you pass an argument to <code class="bg-gray-200 px-1 py-0.5 rounded">next()</code>, Express treats it as an error and skips any remaining non-error handling middleware functions.
        </p>
        <div class="bg-gray-800 text-white p-4 rounded-md mb-4 overflow-x-auto">
          <code>
            app.get('/products/:id', (req, res, next) => {<br>
            &nbsp;&nbsp;// Validation<br>
            &nbsp;&nbsp;const productId = parseInt(req.params.id);<br>
            &nbsp;&nbsp;if (isNaN(productId)) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const err = new Error('Invalid product ID');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;err.status = 400;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return next(err);<br>
            &nbsp;&nbsp;}<br>
            <br>
            &nbsp;&nbsp;// Product lookup (example)<br>
            &nbsp;&nbsp;const product = findProductById(productId);<br>
            &nbsp;&nbsp;if (!product) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const err = new Error('Product not found');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;err.status = 404;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;return next(err);<br>
            &nbsp;&nbsp;}<br>
            <br>
            &nbsp;&nbsp;res.json(product);<br>
            });
          </code>
        </div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Handling Asynchronous Errors</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          For asynchronous code in Express routes, you need to catch errors and pass them to <code class="bg-gray-200 px-1 py-0.5 rounded">next()</code>. Otherwise, they won't be caught by Express's error handlers.
        </p>
        <div class="bg-gray-800 text-white p-4 rounded-md mb-4 overflow-x-auto">
          <code>
            // Using Promises<br>
            app.get('/users/:id', (req, res, next) => {<br>
            &nbsp;&nbsp;findUserById(req.params.id)<br>
            &nbsp;&nbsp;&nbsp;&nbsp;.then(user => {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!user) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const err = new Error('User not found');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err.status = 404;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;res.json(user);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;})<br>
            &nbsp;&nbsp;&nbsp;&nbsp;.catch(next); // Passing the error to next()<br>
            });<br>
            <br>
            // Using async/await (with try/catch)<br>
            app.get('/posts/:id', async (req, res, next) => {<br>
            &nbsp;&nbsp;try {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const post = await findPostById(req.params.id);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (!post) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;const err = new Error('Post not found');<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;err.status = 404;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;res.json(post);<br>
            &nbsp;&nbsp;} catch (err) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;next(err); // Passing the error to next()<br>
            &nbsp;&nbsp;}<br>
            });
          </code>
        </div>
        <p class="mb-4 text-gray-600 leading-relaxed">
          Express 5 will come with built-in support for async error handling without needing to use <code class="bg-gray-200 px-1 py-0.5 rounded">try/catch</code> blocks.
        </p>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Centralized Error Handling</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          A best practice is to create centralized error handling middleware to handle all errors in your Express application. This provides consistency in error responses and makes it easier to manage error logging and reporting.
        </p>
        <div class="bg-gray-800 text-white p-4 rounded-md mb-4 overflow-x-auto">
          <code>
            // error-handler.js<br>
            module.exports = (err, req, res, next) => {<br>
            &nbsp;&nbsp;// Set locals, only providing error in development<br>
            &nbsp;&nbsp;res.locals.message = err.message;<br>
            &nbsp;&nbsp;res.locals.error = req.app.get('env') === 'development' ? err : {};<br>
            <br>
            &nbsp;&nbsp;// Get the status code or default to 500 (Server Error)<br>
            &nbsp;&nbsp;const statusCode = err.status || 500;<br>
            <br>
            &nbsp;&nbsp;// Log the error<br>
            &nbsp;&nbsp;console.error(`[Error ${statusCode}] ${err.message}`, err.stack);<br>
            <br>
            &nbsp;&nbsp;// Send the response<br>
            &nbsp;&nbsp;res.status(statusCode).json({<br>
            &nbsp;&nbsp;&nbsp;&nbsp;status: 'error',<br>
            &nbsp;&nbsp;&nbsp;&nbsp;message: statusCode === 500 && req.app.get('env') !== 'development'<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;? 'Internal server error'<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;: err.message<br>
            &nbsp;&nbsp;});<br>
            };<br>
            <br>
            // app.js<br>
            const express = require('express');<br>
            const errorHandler = require('./error-handler');<br>
            const app = express();<br>
            <br>
            // Routes and middleware<br>
            // ...<br>
            <br>
            // Error handling middleware (should be last)<br>
            app.use(errorHandler);
          </code>
        </div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">Custom Error Classes</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          Creating custom error classes can help you organize different types of errors in your application.
        </p>
        <div class="bg-gray-800 text-white p-4 rounded-md mb-4 overflow-x-auto">
          <code>
            // errors/app-error.js<br>
            class AppError extends Error {<br>
            &nbsp;&nbsp;constructor(message, status) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;super(message);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.name = this.constructor.name;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;this.status = status || 500;<br>
            &nbsp;&nbsp;&nbsp;&nbsp;Error.captureStackTrace(this, this.constructor);<br>
            &nbsp;&nbsp;}<br>
            }<br>
            <br>
            // errors/not-found-error.js<br>
            const AppError = require('./app-error');<br>
            <br>
            class NotFoundError extends AppError {<br>
            &nbsp;&nbsp;constructor(message = 'Resource not found') {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;super(message, 404);<br>
            &nbsp;&nbsp;}<br>
            }<br>
            <br>
            // Usage<br>
            app.get('/items/:id', async (req, res, next) => {<br>
            &nbsp;&nbsp;try {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;const item = await getItem(req.params.id);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;if (!item) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new NotFoundError(`Item ${req.params.id} not found`);<br>
            &nbsp;&nbsp;&nbsp;&nbsp;}<br>
            &nbsp;&nbsp;&nbsp;&nbsp;res.json(item);<br>
            &nbsp;&nbsp;} catch (err) {<br>
            &nbsp;&nbsp;&nbsp;&nbsp;next(err);<br>
            &nbsp;&nbsp;}<br>
            });
          </code>
        </div>
      </section>

      <section class="mb-8">
        <h2 class="text-2xl font-semibold mb-4 text-gray-700">404 Errors (Not Found)</h2>
        <p class="mb-4 text-gray-600 leading-relaxed">
          In Express, 404 responses are not the result of an error, so the error-handler middleware will not capture them. To handle 404 responses, add a middleware function at the bottom of the middleware stack (but before any error handlers) to handle a 404 response.
        </p>
        <div class="bg-gray-800 text-white p-4 rounded-md mb-4 overflow-x-auto">
          <code>
            // All other routes not handled before will return 404<br>
            app.use((req, res, next) => {<br>
            &nbsp;&nbsp;const err = new Error(`Not Found - ${req.originalUrl}`);<br>
            &nbsp;&nbsp;err.status = 404;<br>
            &nbsp;&nbsp;next(err);<br>
            });<br>
            <br>
            // Error handling middleware<br>
            app.use((err, req, res, next) => {<br>
            &nbsp;&nbsp;res.status(err.status || 500).json({<br>
            &nbsp;&nbsp;&nbsp;&nbsp;message: err.message,<br>
            &nbsp;&nbsp;&nbsp;&nbsp;error: req.app.get('env') === 'development' ? err : {}<br>
            &nbsp;&nbsp;});<br>
            });
          </code>
        </div>
      </section>
    </div>
  </main>
  
  <!-- Footer will be inserted here by JavaScript -->
  <div id="footer"></div>
  
  <!-- Common JavaScript for header and footer -->
  <script src="../js/common.js"></script>
</body>
</html>
