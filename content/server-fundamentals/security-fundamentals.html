<div class="content-section">
  <h1 class="text-3xl font-bold text-gray-900 dark:text-white mb-6">
    Security Fundamentals
  </h1>

  <div class="prose max-w-none">
    <p class="text-lg text-gray-600 dark:text-gray-300 mb-8">
      Security should be a primary concern from the beginning of any backend
      development project. This guide covers essential security practices,
      common vulnerabilities, and how to protect your applications.
    </p>

    <div
      class="bg-red-50 dark:bg-red-900/20 border border-red-200 dark:border-red-800 rounded-lg p-6 mb-8"
    >
      <h3 class="text-lg font-semibold text-red-900 dark:text-red-100 mb-3">
        ⚠️ Security First Mindset
      </h3>
      <p class="text-red-800 dark:text-red-200">
        Security is not an add-on feature—it must be built into your application
        from the ground up. Never postpone security considerations until later
        in development.
      </p>
    </div>

    <div
      class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-6 mb-8"
    >
      <h3 class="text-lg font-semibold text-blue-900 dark:text-blue-100 mb-3">
        Learning Objectives
      </h3>
      <ul
        class="list-disc list-inside text-blue-800 dark:text-blue-200 space-y-2"
      >
        <li>Understand common web application vulnerabilities</li>
        <li>Implement authentication and authorization</li>
        <li>Secure data transmission and storage</li>
        <li>Apply input validation and sanitization</li>
        <li>Configure security headers and middleware</li>
      </ul>
    </div>

    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mt-8 mb-4">
      OWASP Top 10 Vulnerabilities
    </h2>

    <p class="text-gray-600 dark:text-gray-300 mb-4">
      The OWASP Top 10 represents the most critical web application security
      risks. Let's understand each one:
    </p>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-red-600 dark:text-red-400 mb-2">
          1. Injection
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-300 mb-3">
          SQL, NoSQL, OS, and LDAP injection flaws
        </p>
        <div class="text-xs bg-gray-50 dark:bg-gray-700 p-2 rounded">
          <strong>Prevention:</strong> Use parameterized queries, ORM, input
          validation
        </div>
      </div>

      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-red-600 dark:text-red-400 mb-2">
          2. Broken Authentication
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-300 mb-3">
          Session management and credential vulnerabilities
        </p>
        <div class="text-xs bg-gray-50 dark:bg-gray-700 p-2 rounded">
          <strong>Prevention:</strong> Strong passwords, MFA, secure session
          management
        </div>
      </div>

      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-red-600 dark:text-red-400 mb-2">
          3. Sensitive Data Exposure
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-300 mb-3">
          Inadequate protection of sensitive information
        </p>
        <div class="text-xs bg-gray-50 dark:bg-gray-700 p-2 rounded">
          <strong>Prevention:</strong> Encryption at rest and in transit, proper
          key management
        </div>
      </div>

      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-red-600 dark:text-red-400 mb-2">
          4. XML External Entities (XXE)
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-300 mb-3">
          Poorly configured XML processors
        </p>
        <div class="text-xs bg-gray-50 dark:bg-gray-700 p-2 rounded">
          <strong>Prevention:</strong> Disable XML external entity processing
        </div>
      </div>

      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-red-600 dark:text-red-400 mb-2">
          5. Broken Access Control
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-300 mb-3">
          Improper enforcement of user permissions
        </p>
        <div class="text-xs bg-gray-50 dark:bg-gray-700 p-2 rounded">
          <strong>Prevention:</strong> Principle of least privilege, proper
          authorization checks
        </div>
      </div>

      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-red-600 dark:text-red-400 mb-2">
          6. Security Misconfiguration
        </h4>
        <p class="text-sm text-gray-600 dark:text-gray-300 mb-3">
          Insecure default configurations
        </p>
        <div class="text-xs bg-gray-50 dark:bg-gray-700 p-2 rounded">
          <strong>Prevention:</strong> Regular security assessments, remove
          defaults
        </div>
      </div>
    </div>

    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mt-8 mb-4">
      Authentication & Authorization
    </h2>

    <p class="text-gray-600 dark:text-gray-300 mb-4">
      Implementing secure authentication and authorization is critical for
      protecting user accounts and resources.
    </p>

    <div class="tabbed-content mb-6" data-tabbed>
      <div class="tab-buttons flex space-x-2 mb-4">
        <button
          class="tab-button active bg-blue-500 text-white px-4 py-2 rounded"
          data-tab="jwt"
        >
          JWT Authentication
        </button>
        <button
          class="tab-button bg-gray-200 text-gray-700 px-4 py-2 rounded"
          data-tab="session"
        >
          Session-based
        </button>
        <button
          class="tab-button bg-gray-200 text-gray-700 px-4 py-2 rounded"
          data-tab="oauth"
        >
          OAuth 2.0
        </button>
      </div>

      <div class="tab-content active" data-content="jwt">
        <h4 class="font-semibold text-gray-900 dark:text-white mb-3">
          JWT (JSON Web Tokens)
        </h4>
        <p class="text-gray-600 dark:text-gray-300 mb-4">
          Stateless authentication using signed tokens.
        </p>

        <div class="code-block mb-4">
          <div class="code-header">
            <span>JWT Implementation</span>
            <button class="copy-btn" data-copy="jwt-auth">Copy</button>
          </div>
          <pre><code id="jwt-auth">const jwt = require('jsonwebtoken');
const bcrypt = require('bcrypt');

// Generate JWT token
const generateToken = (user) => {
    return jwt.sign(
        { 
            id: user._id, 
            email: user.email,
            role: user.role 
        },
        process.env.JWT_SECRET,
        { 
            expiresIn: process.env.JWT_EXPIRES_IN,
            issuer: 'your-app-name',
            audience: 'your-app-users'
        }
    );
};

// Verify JWT middleware
const authenticateToken = (req, res, next) => {
    const authHeader = req.headers['authorization'];
    const token = authHeader && authHeader.split(' ')[1];

    if (!token) {
        return res.status(401).json({ error: 'Access token required' });
    }

    jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
        if (err) {
            return res.status(403).json({ error: 'Invalid token' });
        }
        req.user = user;
        next();
    });
};

// Login endpoint
app.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        
        // Find user
        const user = await User.findOne({ email });
        if (!user) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        // Verify password
        const isValidPassword = await bcrypt.compare(password, user.password);
        if (!isValidPassword) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        // Generate token
        const token = generateToken(user);
        
        res.json({
            token,
            user: {
                id: user._id,
                email: user.email,
                role: user.role
            }
        });
    } catch (error) {
        res.status(500).json({ error: 'Server error' });
    }
});</code></pre>
        </div>

        <div
          class="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-4"
        >
          <h5 class="font-semibold text-yellow-800 dark:text-yellow-200 mb-2">
            JWT Best Practices
          </h5>
          <ul
            class="text-sm text-yellow-700 dark:text-yellow-300 list-disc list-inside space-y-1"
          >
            <li>Use strong secrets (minimum 256 bits)</li>
            <li>Set appropriate expiration times</li>
            <li>Include only necessary claims</li>
            <li>Implement token refresh mechanism</li>
            <li>Store tokens securely on client side</li>
          </ul>
        </div>
      </div>

      <div class="tab-content hidden" data-content="session">
        <h4 class="font-semibold text-gray-900 dark:text-white mb-3">
          Session-based Authentication
        </h4>
        <p class="text-gray-600 dark:text-gray-300 mb-4">
          Server-side session storage with cookies.
        </p>

        <div class="code-block mb-4">
          <div class="code-header">
            <span>Session Configuration</span>
            <button class="copy-btn" data-copy="session-auth">Copy</button>
          </div>
          <pre><code id="session-auth">const session = require('express-session');
const MongoStore = require('connect-mongo');

app.use(session({
    secret: process.env.SESSION_SECRET,
    resave: false,
    saveUninitialized: false,
    store: MongoStore.create({
        mongoUrl: process.env.DATABASE_URL,
        touchAfter: 24 * 3600 // lazy session update
    }),
    cookie: {
        secure: process.env.NODE_ENV === 'production', // HTTPS only in production
        httpOnly: true, // Prevent XSS
        maxAge: 1000 * 60 * 60 * 24 * 7, // 1 week
        sameSite: 'strict' // CSRF protection
    }
}));

// Login endpoint
app.post('/login', async (req, res) => {
    try {
        const { email, password } = req.body;
        
        const user = await User.findOne({ email });
        const isValid = user && await bcrypt.compare(password, user.password);
        
        if (!isValid) {
            return res.status(401).json({ error: 'Invalid credentials' });
        }
        
        // Store user in session
        req.session.userId = user._id;
        req.session.userRole = user.role;
        
        res.json({ 
            message: 'Login successful',
            user: { id: user._id, email: user.email, role: user.role }
        });
    } catch (error) {
        res.status(500).json({ error: 'Server error' });
    }
});

// Session middleware
const requireAuth = (req, res, next) => {
    if (!req.session.userId) {
        return res.status(401).json({ error: 'Authentication required' });
    }
    next();
};</code></pre>
        </div>
      </div>

      <div class="tab-content hidden" data-content="oauth">
        <h4 class="font-semibold text-gray-900 dark:text-white mb-3">
          OAuth 2.0 Integration
        </h4>
        <p class="text-gray-600 dark:text-gray-300 mb-4">
          Third-party authentication with providers like Google, GitHub.
        </p>

        <div class="code-block">
          <div class="code-header">
            <span>OAuth with Passport.js</span>
            <button class="copy-btn" data-copy="oauth-auth">Copy</button>
          </div>
          <pre><code id="oauth-auth">const passport = require('passport');
const GoogleStrategy = require('passport-google-oauth20').Strategy;

passport.use(new GoogleStrategy({
    clientID: process.env.GOOGLE_CLIENT_ID,
    clientSecret: process.env.GOOGLE_CLIENT_SECRET,
    callbackURL: "/auth/google/callback"
}, async (accessToken, refreshToken, profile, done) => {
    try {
        // Check if user exists
        let user = await User.findOne({ googleId: profile.id });
        
        if (user) {
            return done(null, user);
        }
        
        // Create new user
        user = await User.create({
            googleId: profile.id,
            email: profile.emails[0].value,
            name: profile.displayName,
            avatar: profile.photos[0].value
        });
        
        done(null, user);
    } catch (error) {
        done(error, null);
    }
}));

// Routes
app.get('/auth/google',
    passport.authenticate('google', { scope: ['profile', 'email'] })
);

app.get('/auth/google/callback',
    passport.authenticate('google', { failureRedirect: '/login' }),
    (req, res) => {
        // Successful authentication
        res.redirect('/dashboard');
    }
);</code></pre>
        </div>
      </div>
    </div>

    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mt-8 mb-4">
      Password Security
    </h2>

    <p class="text-gray-600 dark:text-gray-300 mb-4">
      Proper password handling is crucial for user account security.
    </p>

    <div class="code-block mb-6">
      <div class="code-header">
        <span>Password Hashing with bcrypt</span>
        <button class="copy-btn" data-copy="password-security">Copy</button>
      </div>
      <pre><code id="password-security">const bcrypt = require('bcrypt');
const zxcvbn = require('zxcvbn'); // Password strength checker

// Password validation
const validatePassword = (password) => {
    const minLength = 8;
    const hasUpperCase = /[A-Z]/.test(password);
    const hasLowerCase = /[a-z]/.test(password);
    const hasNumbers = /\d/.test(password);
    const hasNonalphas = /\W/.test(password);
    
    if (password.length < minLength) {
        throw new Error('Password must be at least 8 characters long');
    }
    
    if (!(hasUpperCase && hasLowerCase && hasNumbers && hasNonalphas)) {
        throw new Error('Password must contain uppercase, lowercase, numbers, and special characters');
    }
    
    // Check password strength
    const result = zxcvbn(password);
    if (result.score < 3) {
        throw new Error('Password is too weak. Try a longer, more complex password.');
    }
    
    return true;
};

// Hash password
const hashPassword = async (password) => {
    validatePassword(password);
    const saltRounds = 12; // Adjust based on security requirements vs performance
    return await bcrypt.hash(password, saltRounds);
};

// User registration
app.post('/register', async (req, res) => {
    try {
        const { email, password, confirmPassword } = req.body;
        
        // Validate input
        if (!email || !password || !confirmPassword) {
            return res.status(400).json({ error: 'All fields are required' });
        }
        
        if (password !== confirmPassword) {
            return res.status(400).json({ error: 'Passwords do not match' });
        }
        
        // Check if user exists
        const existingUser = await User.findOne({ email });
        if (existingUser) {
            return res.status(409).json({ error: 'User already exists' });
        }
        
        // Hash password and create user
        const hashedPassword = await hashPassword(password);
        const user = await User.create({
            email,
            password: hashedPassword
        });
        
        // Generate token
        const token = generateToken(user);
        
        res.status(201).json({
            message: 'User created successfully',
            token,
            user: {
                id: user._id,
                email: user.email
            }
        });
    } catch (error) {
        if (error.message.includes('Password')) {
            return res.status(400).json({ error: error.message });
        }
        res.status(500).json({ error: 'Server error' });
    }
});</code></pre>
    </div>

    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mt-8 mb-4">
      Input Validation & Sanitization
    </h2>

    <p class="text-gray-600 dark:text-gray-300 mb-4">
      Always validate and sanitize user input to prevent injection attacks and
      data corruption.
    </p>

    <div class="expandable-section mb-6" data-expandable>
      <button
        class="expandable-header bg-gray-100 dark:bg-gray-700 w-full text-left p-4 rounded-lg font-semibold text-gray-900 dark:text-white"
      >
        Validation with Joi
        <span class="float-right">+</span>
      </button>
      <div
        class="expandable-content hidden mt-4 p-4 bg-gray-50 dark:bg-gray-800 rounded-lg"
      >
        <div class="code-block">
          <div class="code-header">
            <span>Input Validation Schema</span>
            <button class="copy-btn" data-copy="joi-validation">Copy</button>
          </div>
          <pre><code id="joi-validation">const Joi = require('joi');

// User registration schema
const userRegistrationSchema = Joi.object({
    email: Joi.string()
        .email({ minDomainSegments: 2, tlds: { allow: ['com', 'net', 'org'] } })
        .required()
        .messages({
            'string.email': 'Please provide a valid email address',
            'any.required': 'Email is required'
        }),
    
    password: Joi.string()
        .min(8)
        .pattern(new RegExp('^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*])'))
        .required()
        .messages({
            'string.min': 'Password must be at least 8 characters long',
            'string.pattern.base': 'Password must contain uppercase, lowercase, numbers, and special characters'
        }),
    
    name: Joi.string()
        .alphanum()
        .min(2)
        .max(50)
        .required()
        .messages({
            'string.alphanum': 'Name must only contain alphanumeric characters',
            'string.min': 'Name must be at least 2 characters long',
            'string.max': 'Name cannot be longer than 50 characters'
        }),
    
    age: Joi.number()
        .integer()
        .min(13)
        .max(120)
        .optional(),
    
    phone: Joi.string()
        .pattern(/^[+]?[(]?[\d\s\-\(\)]+$/)
        .optional()
        .messages({
            'string.pattern.base': 'Please provide a valid phone number'
        })
});

// Validation middleware
const validateInput = (schema) => {
    return (req, res, next) => {
        const { error, value } = schema.validate(req.body, {
            abortEarly: false, // Return all validation errors
            allowUnknown: false, // Reject unknown fields
            stripUnknown: true // Remove unknown fields
        });
        
        if (error) {
            const errors = error.details.map(detail => ({
                field: detail.path.join('.'),
                message: detail.message
            }));
            
            return res.status(400).json({
                error: 'Validation failed',
                details: errors
            });
        }
        
        req.body = value; // Use sanitized values
        next();
    };
};

// Usage
app.post('/register', validateInput(userRegistrationSchema), async (req, res) => {
    // req.body is now validated and sanitized
    // ... registration logic
});</code></pre>
        </div>
      </div>
    </div>

    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mt-8 mb-4">
      Security Headers & Middleware
    </h2>

    <p class="text-gray-600 dark:text-gray-300 mb-4">
      Implement security headers and middleware to protect against common
      attacks.
    </p>

    <div class="code-block mb-6">
      <div class="code-header">
        <span>Security Middleware Setup</span>
        <button class="copy-btn" data-copy="security-middleware">Copy</button>
      </div>
      <pre><code id="security-middleware">const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const mongoSanitize = require('express-mongo-sanitize');
const xss = require('xss-clean');
const hpp = require('hpp');
const cors = require('cors');

// Security headers
app.use(helmet({
    contentSecurityPolicy: {
        directives: {
            defaultSrc: ["'self'"],
            styleSrc: ["'self'", "'unsafe-inline'", "https://fonts.googleapis.com"],
            fontSrc: ["'self'", "https://fonts.gstatic.com"],
            scriptSrc: ["'self'"],
            imgSrc: ["'self'", "data:", "https:"],
        },
    },
    hsts: {
        maxAge: 31536000,
        includeSubDomains: true,
        preload: true
    }
}));

// Rate limiting
const limiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 100, // Limit each IP to 100 requests per windowMs
    message: {
        error: 'Too many requests from this IP, please try again later.'
    },
    standardHeaders: true,
    legacyHeaders: false
});

const authLimiter = rateLimit({
    windowMs: 15 * 60 * 1000, // 15 minutes
    max: 5, // Limit auth attempts
    message: {
        error: 'Too many authentication attempts, please try again later.'
    }
});

app.use('/api/', limiter);
app.use('/api/auth/', authLimiter);

// CORS configuration
app.use(cors({
    origin: process.env.ALLOWED_ORIGINS?.split(',') || ['http://localhost:3000'],
    credentials: true,
    optionsSuccessStatus: 200
}));

// Body parsing with size limits
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Data sanitization against NoSQL query injection
app.use(mongoSanitize());

// Data sanitization against XSS
app.use(xss());

// Prevent parameter pollution
app.use(hpp({
    whitelist: ['sort', 'fields'] // Allow these parameters to be duplicated
}));

// Custom security middleware
app.use((req, res, next) => {
    // Remove sensitive headers
    res.removeHeader('X-Powered-By');
    
    // Add custom security headers
    res.setHeader('X-Content-Type-Options', 'nosniff');
    res.setHeader('X-Frame-Options', 'DENY');
    res.setHeader('X-XSS-Protection', '1; mode=block');
    res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
    
    next();
});</code></pre>
    </div>

    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mt-8 mb-4">
      Environment & Configuration Security
    </h2>

    <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-6">
      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-gray-900 dark:text-white mb-3">
          🔐 Secrets Management
        </h4>
        <ul class="text-sm text-gray-600 dark:text-gray-300 space-y-2">
          <li>• Use environment variables for secrets</li>
          <li>• Never commit secrets to version control</li>
          <li>• Use key management services (AWS KMS, Azure Key Vault)</li>
          <li>• Rotate secrets regularly</li>
          <li>• Use different secrets for each environment</li>
        </ul>
      </div>

      <div
        class="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg p-6"
      >
        <h4 class="font-semibold text-gray-900 dark:text-white mb-3">
          🛡️ Production Hardening
        </h4>
        <ul class="text-sm text-gray-600 dark:text-gray-300 space-y-2">
          <li>• Disable debug mode and stack traces</li>
          <li>• Use HTTPS everywhere</li>
          <li>• Implement proper logging (no sensitive data)</li>
          <li>• Regular security updates</li>
          <li>• Principle of least privilege</li>
        </ul>
      </div>
    </div>

    <h2 class="text-2xl font-bold text-gray-900 dark:text-white mt-8 mb-4">
      Security Testing & Monitoring
    </h2>

    <div class="code-block mb-6">
      <div class="code-header">
        <span>Security Testing Example</span>
        <button class="copy-btn" data-copy="security-testing">Copy</button>
      </div>
      <pre><code id="security-testing">// Security test examples with Jest and Supertest
const request = require('supertest');
const app = require('../app');

describe('Security Tests', () => {
    
    describe('Rate Limiting', () => {
        it('should limit repeated requests', async () => {
            const requests = [];
            
            // Make multiple requests quickly
            for (let i = 0; i < 10; i++) {
                requests.push(request(app).get('/api/test'));
            }
            
            const responses = await Promise.all(requests);
            const rateLimited = responses.some(res => res.status === 429);
            
            expect(rateLimited).toBe(true);
        });
    });
    
    describe('Input Validation', () => {
        it('should reject XSS attempts', async () => {
            const xssPayload = {
                name: '<script>alert("xss")</script>',
                email: 'test@example.com'
            };
            
            const response = await request(app)
                .post('/api/users')
                .send(xssPayload);
            
            expect(response.status).toBe(400);
        });
        
        it('should reject SQL injection attempts', async () => {
            const sqlPayload = {
                email: "admin@example.com' OR '1'='1",
                password: 'password'
            };
            
            const response = await request(app)
                .post('/api/auth/login')
                .send(sqlPayload);
            
            expect(response.status).toBe(400);
        });
    });
    
    describe('Authentication', () => {
        it('should require valid JWT token', async () => {
            const response = await request(app)
                .get('/api/protected')
                .set('Authorization', 'Bearer invalid-token');
            
            expect(response.status).toBe(403);
        });
        
        it('should reject requests without token', async () => {
            const response = await request(app)
                .get('/api/protected');
            
            expect(response.status).toBe(401);
        });
    });
});</code></pre>
    </div>

    <div
      class="bg-green-50 dark:bg-green-900/20 border border-green-200 dark:border-green-800 rounded-lg p-6 mb-8"
    >
      <h3 class="text-lg font-semibold text-green-900 dark:text-green-100 mb-3">
        Security Checklist
      </h3>
      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        <ul
          class="list-disc list-inside text-green-800 dark:text-green-200 space-y-2"
        >
          <li>✅ Implement proper authentication</li>
          <li>✅ Use HTTPS everywhere</li>
          <li>✅ Validate and sanitize all inputs</li>
          <li>✅ Set up security headers</li>
          <li>✅ Implement rate limiting</li>
          <li>✅ Use secure password hashing</li>
        </ul>
        <ul
          class="list-disc list-inside text-green-800 dark:text-green-200 space-y-2"
        >
          <li>✅ Keep dependencies updated</li>
          <li>✅ Implement proper logging</li>
          <li>✅ Use environment variables for secrets</li>
          <li>✅ Regular security testing</li>
          <li>✅ Implement CORS properly</li>
          <li>✅ Follow principle of least privilege</li>
        </ul>
      </div>
    </div>

    <div
      class="bg-yellow-50 dark:bg-yellow-900/20 border border-yellow-200 dark:border-yellow-800 rounded-lg p-6"
    >
      <h3
        class="text-lg font-semibold text-yellow-900 dark:text-yellow-100 mb-3"
      >
        Next Steps
      </h3>
      <p class="text-yellow-800 dark:text-yellow-200 mb-3">
        Security is an ongoing process, not a one-time setup. With these
        fundamentals in place, you're ready to move on to building Express.js
        applications with security best practices built in.
      </p>
      <p class="text-yellow-800 dark:text-yellow-200">
        <strong>Remember:</strong> Stay updated with the latest security threats
        and regularly audit your applications for vulnerabilities using tools
        like npm audit, Snyk, or OWASP ZAP.
      </p>
    </div>
  </div>
</div>
